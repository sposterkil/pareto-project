#!/usr/bin/env python

import csv
import re
import shutil
import string
import sys
from tempfile import NamedTemporaryFile


class CSVParetoer():

    """
    This class represents an instance of paretoization.  In short,
    it operates on a CSV file and produces another file with a list
    of tags to be applied to that file.
    """

    # Build a translation table that turns all punctuation into spaces
    replace_punctuation = string.maketrans(string.punctuation,
                                           ' ' * len(string.punctuation))

    def __init__(self, start_row, file_to_count, tag_file):
        self.file_to_count = file_to_count
        self.tag_file = tag_file
        self.start_row = start_row
        try:
            self.stop_words = open("stopwords.txt", "r").read().split()
        except IOError, e:
            print "stopwords.txt not found.  Output will contain many common words."

        self.counts = {}
        dialect = csv.Sniffer().sniff(self.file_to_count.read(1024))
        self.file_to_count.seek(0)
        self.reader = csv.reader(self.file_to_count, dialect)

    def update_counts(self, str_to_count):
        # Replaces all punctuation with spaces...
        zero_punctuation = str_to_count.translate(self.replace_punctuation)
        # ...and then splits on spaces, so we have a punctuation-free
        # list of words
        word_list = zero_punctuation.split()
        for word in word_list:
            word = word.upper()
            if word not in self.stop_words and not word.isdigit():
                if word in self.counts:
                    # Increment the count if it exists...
                    self.counts[word] += 1
                else:
                    # And set it to one otherwise. += vs =.
                    self.counts[word] = 1

    def pareto(self, column_list):
        self.last_column_list = column_list
        # Skip the header rows, if they exist
        for i in xrange(0, self.start_row):
            next(self.reader)
        for line in self.reader:
            for column in column_list:
                self.update_counts(line[column])

    def write_counts(self):
        count_tuples = self.counts.iteritems()
        # Sort them in decreasing order of frequency
        sorted_tuples = sorted(count_tuples, key=lambda word: -word[1])
        self.tag_file.write("# Words by Frequency in columns:\n")
        self.tag_file.write(str(self.last_column_list) + "\n")
        self.tag_file.write(
            "# Remove the tags you don't want to apply to the file.\n")
        self.tag_file.write("############ TAGS FOLLOW ############\n")

        for word, count in sorted_tuples:
            self.tag_file.write("%s: %s \n" % (word, count))


def pad_insert(l, index, value):
    l += [''] * (index - len(l))
    l.append(value)
    return l


class CSVTagger():

    """
    Class for tagging a CSV file with a list of words, like that
    generated by CSVParetoer.  Creates a column for each tag at the
    end of the file, and fills that column with an X if the
    corresponding row contains that column's word.
    """

    def __init__(self, column_list, tag_file, file_to_tag):
        self.column_list = column_list
        self.file_to_tag = file_to_tag
        self.tag_file = tag_file
        self.file_to_tag.seek(0)
        dialect = csv.Sniffer().sniff(self.file_to_tag.read(1024))
        self.file_to_tag.seek(0)
        self.reader = csv.reader(self.file_to_tag, dialect)

    def get_end(self):
        # Finds the length of the longest row in the file, so we know
        # where it's safe to start writing tags
        return max([len(line) for line in self.reader]) + 1

    def build_tag_list(self):
        tag_list = []
        # Captures a word followed by a colon followed by anything
        strip_colons = re.compile(r"(\w+):.*")
        for line in self.tag_file:
            # Adds the WORD on each line to the tag_list
            match = strip_colons.match(line)
            if match:
                tag_list.append(match.group(1))
        return tag_list

    def tag_row(self, row, tags, start_col):
        if len(tags) > 0:
            for tag in tags:
                col_num = start_col + self.tag_list.index(tag)
                tagged_row = pad_insert(row, col_num, "X")
            self.writer.writerow(tagged_row)
        else:
            self.writer.writerow(row)

    def write_headers(self):
        self.file_to_tag.seek(0)
        headers = next(self.reader)
        for x in xrange(self.start_col - len(headers)):
            headers.append(x)
        for tag in self.tag_list:
            headers.append(tag)
        self.writer.writerow(headers)

    def add_tags(self):
        temp_file = NamedTemporaryFile(delete=False)
        to_check = ""
        self.start_col = self.get_end()
        self.tag_list = self.build_tag_list()
        self.writer = csv.writer(temp_file, dialect=self.reader.dialect,
                                 escapechar="\\")
        self.file_to_tag.seek(0)
        for row in self.reader:
            to_check = " ".join([row[column] for column in self.column_list])
            to_tag = []
            for tag in self.tag_list:
                if tag in to_check.upper():
                    to_tag.append(tag)
            self.tag_row(row, to_tag, self.start_col)
        temp_file.seek(0)
        self.write_headers()
        shutil.move(temp_file.name, self.file_to_tag.name)


if __name__ == '__main__':
    input_path = sys.argv[1]
    taglist_path = sys.argv[2]
    num_header_rows = int(raw_input(
        "How many rows should we exclude as Header rows?\n"))
    if num_header_rows > 1:
        title_row = raw_input(
            "Which of these rows contains the column titles?\n")
    column_string = raw_input(
        "Which columns would you like to read from? Numbers separated by commas, please.\n")
    column_list = [int(x) - 1 for x in column_string.split(",")]
    print "Opening files..."
    try:
        file_to_count = open(input_path)
    except IOError, e:
        print "Error opening %s." % input_path
        sys.exit(1)
    try:
        file_to_count = open(taglist_path)
    except IOError, e:
        print "Error opening %s." % taglist_path
        sys.exit(1)
    paretoer = CSVParetoer(num_header_rows, file_to_count, tag_list)
    print "Counting..."
    paretoer.pareto(column_list)
    print "Writing output..."
    paretoer.write_counts()
    print "Done."
    raw_input("""Please edit the file at %s to select the tags you wish
to apply, and press enter when done.""" % taglist_path)
    print "Tagging File..."
    tagger = CSVTagger(column_list, taglist_path, input_path)
    tagger.add_tags()
    print "Done."
